using UnityEngine;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace PaintIn3D
{
	/// <summary>This base class allows you to easily create components that can have their paint points connected together to form lines.</summary>
	public abstract class P3dHitConnector : MonoBehaviour
	{
		class Link
		{
			public object  Owner;
			public Vector3 WorldPosition;
			public float   Pressure;
			public float   Age;
			public bool    Preview;
		}

		/// <summary>If you enable this then the hit points generated by this component will be connected into lines, allowing you to paint continuously.</summary>
		public bool ConnectHits { set { connectHits = value; } get { return connectHits; } } [SerializeField] protected bool connectHits;

		[System.NonSerialized]
		private static List<Link> links = new List<Link>();

		[System.NonSerialized]
		private static Stack<Link> linkPool = new Stack<Link>();

		[System.NonSerialized]
		protected P3dHitCache hitCache = new P3dHitCache();

		public P3dHitCache HitCache
		{
			get
			{
				return hitCache;
			}
		}

		[ContextMenu("Clear Hit Cache")]
		public void ClearHitCache()
		{
			hitCache.Clear();
		}

		protected void BreakHits(object owner)
		{
			for (var i = links.Count - 1; i >= 0; i--)
			{
				var link = links[i];

				if (link.Owner == owner)
				{
					links.RemoveAt(i);

					linkPool.Push(link);

					return;
				}
			}
		}

		protected void DispatchHits(bool preview, Collider collider, Vector3 worldPosition, Quaternion worldRotation, float pressure, object owner)
		{
			if (connectHits == true && owner != null)
			{
				var link = default(Link);

				if (TryGetLink(owner, ref link) == true)
				{
					if (link.Preview == preview)
					{
						hitCache.InvokeLines(gameObject, null, null, preview, link.WorldPosition, worldPosition, link.Pressure, pressure);
					}
					else
					{
						hitCache.InvokePoints(gameObject, null, null, preview, collider, worldPosition, worldRotation, pressure);
					}
				}
				else
				{
					link = linkPool.Count > 0 ? linkPool.Pop() : new Link();

					link.Owner = owner;

					links.Add(link);

					hitCache.InvokePoints(gameObject, null, null, preview, collider, worldPosition, worldRotation, pressure);
				}

				link.WorldPosition = worldPosition;
				link.Pressure      = pressure;
				link.Preview       = preview;
			}
			else
			{
				hitCache.InvokePoints(gameObject, null, null, preview, collider, worldPosition, worldRotation, pressure);
			}
		}

		protected virtual void Update()
		{
			for (var i = links.Count - 1; i >= 0; i--)
			{
				var link = links[i];

				link.Age += Time.deltaTime;

				if (link.Age > 1.0f)
				{
					link.Age = 0.0f;

					links.RemoveAt(i);

					linkPool.Push(link);
				}
			}
		}

		private bool TryGetLink(object owner, ref Link link)
		{
			for (var i = links.Count - 1; i >= 0; i--)
			{
				link = links[i];

				link.Age = 0.0f;

				if (link.Owner == owner)
				{
					return true;
				}
			}

			return false;
		}
	}
}

#if UNITY_EDITOR
namespace PaintIn3D
{
	public class P3dHitConnector_Editor<T> : P3dEditor<T>
		where T : P3dHitConnector
	{
		protected override void OnInspector()
		{
			Draw("connectHits", "If you enable this then the hit points generated by this component will be connected into lines, allowing you to paint continuously.");
		}
	}
}
#endif